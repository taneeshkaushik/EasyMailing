{"ast":null,"code":"/**\n * Copyright (c) 2017-present, Ephox, Inc.\n *\n * This source code is licensed under the Apache 2 license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport * as React from 'react';\nimport { ScriptLoader } from '../ScriptLoader';\nimport { getTinymce } from '../TinyMCE';\nimport { isFunction, isTextarea, mergePlugins, uuid, configHandlers } from '../Utils';\nimport { EditorPropTypes } from './EditorPropTypes';\n\nvar Editor =\n/** @class */\nfunction (_super) {\n  __extends(Editor, _super);\n\n  function Editor(props) {\n    var _a, _b, _c;\n\n    var _this = _super.call(this, props) || this;\n\n    _this.handleEditorChange = function (_evt) {\n      var _a;\n\n      var editor = _this.editor;\n\n      if (editor) {\n        var newContent = editor.getContent({\n          format: _this.props.outputFormat\n        });\n\n        if (newContent !== _this.currentContent) {\n          _this.currentContent = newContent;\n\n          if (isFunction(_this.props.onEditorChange)) {\n            _this.props.onEditorChange((_a = _this.currentContent) !== null && _a !== void 0 ? _a : '', editor);\n          }\n        }\n      }\n    };\n\n    _this.handleInit = function (initEvent) {\n      var editor = _this.editor;\n\n      if (editor) {\n        editor.setContent(_this.getInitialValue());\n        editor.undoManager.clear();\n        editor.undoManager.add();\n        editor.setDirty(false);\n\n        if (isFunction(_this.props.onEditorChange)) {\n          editor.on('change keyup setcontent', _this.handleEditorChange);\n        }\n\n        if (isFunction(_this.props.onInit)) {\n          _this.props.onInit(initEvent, editor);\n        }\n\n        _this.bindHandlers({});\n      }\n    };\n\n    _this.initialise = function () {\n      var target = _this.elementRef.current;\n\n      if (!target) {\n        return; // Editor has been unmounted\n      }\n\n      var tinymce = getTinymce();\n\n      if (!tinymce) {\n        throw new Error('tinymce should have been loaded into global scope');\n      }\n\n      var finalInit = __assign(__assign({}, _this.props.init), {\n        selector: undefined,\n        target: target,\n        readonly: _this.props.disabled,\n        inline: _this.inline,\n        plugins: mergePlugins(_this.props.init && _this.props.init.plugins, _this.props.plugins),\n        toolbar: _this.props.toolbar || _this.props.init && _this.props.init.toolbar,\n        setup: function setup(editor) {\n          _this.editor = editor;\n          editor.on('init', _this.handleInit);\n\n          if (_this.props.init && isFunction(_this.props.init.setup)) {\n            _this.props.init.setup(editor);\n          }\n        }\n      });\n\n      if (isTextarea(_this.elementRef.current)) {\n        _this.elementRef.current.style.visibility = '';\n      }\n\n      tinymce.init(finalInit);\n    };\n\n    _this.id = _this.props.id || uuid('tiny-react');\n    _this.elementRef = React.createRef();\n    _this.inline = (_c = (_a = _this.props.inline) !== null && _a !== void 0 ? _a : (_b = _this.props.init) === null || _b === void 0 ? void 0 : _b.inline) !== null && _c !== void 0 ? _c : false;\n    _this.boundHandlers = {};\n    return _this;\n  }\n\n  Editor.prototype.componentDidUpdate = function (prevProps) {\n    var _this = this;\n\n    var _a;\n\n    if (this.editor && this.editor.initialized) {\n      this.bindHandlers(prevProps);\n      this.currentContent = (_a = this.currentContent) !== null && _a !== void 0 ? _a : this.editor.getContent({\n        format: this.props.outputFormat\n      });\n\n      if (typeof this.props.value === 'string' && this.props.value !== prevProps.value && this.props.value !== this.currentContent) {\n        var localEditor_1 = this.editor;\n        localEditor_1.undoManager.transact(function () {\n          return localEditor_1.setContent(_this.props.value);\n        });\n      }\n\n      if (typeof this.props.disabled === 'boolean' && this.props.disabled !== prevProps.disabled) {\n        this.editor.setMode(this.props.disabled ? 'readonly' : 'design');\n      }\n    }\n  };\n\n  Editor.prototype.componentDidMount = function () {\n    var _a, _b, _c, _d, _e, _f;\n\n    if (getTinymce() !== null) {\n      this.initialise();\n    } else if (this.elementRef.current && this.elementRef.current.ownerDocument) {\n      ScriptLoader.load(this.elementRef.current.ownerDocument, this.getScriptSrc(), (_b = (_a = this.props.scriptLoading) === null || _a === void 0 ? void 0 : _a.async) !== null && _b !== void 0 ? _b : false, (_d = (_c = this.props.scriptLoading) === null || _c === void 0 ? void 0 : _c.defer) !== null && _d !== void 0 ? _d : false, (_f = (_e = this.props.scriptLoading) === null || _e === void 0 ? void 0 : _e.delay) !== null && _f !== void 0 ? _f : 0, this.initialise);\n    }\n  };\n\n  Editor.prototype.componentWillUnmount = function () {\n    var _this = this;\n\n    var editor = this.editor;\n\n    if (editor) {\n      editor.off('init', this.handleInit);\n\n      if (editor.initialized) {\n        editor.off('change keyup setcontent', this.handleEditorChange);\n        Object.keys(this.boundHandlers).forEach(function (eventName) {\n          editor.off(eventName, _this.boundHandlers[eventName]);\n        });\n        this.boundHandlers = {};\n      }\n\n      editor.remove();\n    }\n  };\n\n  Editor.prototype.render = function () {\n    return this.inline ? this.renderInline() : this.renderIframe();\n  };\n\n  Editor.prototype.renderInline = function () {\n    var _a = this.props.tagName,\n        tagName = _a === void 0 ? 'div' : _a;\n    return React.createElement(tagName, {\n      ref: this.elementRef,\n      id: this.id\n    });\n  };\n\n  Editor.prototype.renderIframe = function () {\n    return React.createElement('textarea', {\n      ref: this.elementRef,\n      style: {\n        visibility: 'hidden'\n      },\n      name: this.props.textareaName,\n      id: this.id\n    });\n  };\n\n  Editor.prototype.getScriptSrc = function () {\n    if (typeof this.props.tinymceScriptSrc === 'string') {\n      return this.props.tinymceScriptSrc;\n    } else {\n      var channel = this.props.cloudChannel;\n      var apiKey = this.props.apiKey ? this.props.apiKey : 'no-api-key';\n      return \"https://cdn.tiny.cloud/1/\" + apiKey + \"/tinymce/\" + channel + \"/tinymce.min.js\";\n    }\n  };\n\n  Editor.prototype.getInitialValue = function () {\n    if (typeof this.props.value === 'string') {\n      return this.props.value;\n    } else if (typeof this.props.initialValue === 'string') {\n      return this.props.initialValue;\n    } else {\n      return '';\n    }\n  };\n\n  Editor.prototype.bindHandlers = function (prevProps) {\n    var _this = this;\n\n    if (this.editor !== undefined) {\n      // typescript chokes trying to understand the type of the lookup function\n      configHandlers(this.editor, prevProps, this.props, this.boundHandlers, function (key) {\n        return _this.props[key];\n      });\n    }\n  };\n\n  Editor.propTypes = EditorPropTypes;\n  Editor.defaultProps = {\n    cloudChannel: '5'\n  };\n  return Editor;\n}(React.Component);\n\nexport { Editor };","map":null,"metadata":{},"sourceType":"module"}