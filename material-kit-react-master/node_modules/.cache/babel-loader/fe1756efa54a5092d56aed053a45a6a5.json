{"ast":null,"code":"import React, { useCallback, createElement, useMemo, Fragment, useRef, useEffect } from 'react';\nimport { useValueFormatter, degreesToRadians, radiansToDegrees, computeArcBoundingBox, useTheme, getLabelGenerator, midAngle, positionFromAngle, absoluteAngleRadians, absoluteAngleDegrees, textPropsByEngine, withContainer, useDimensions, bindDefs, SvgWrapper, ResponsiveWrapper, getRelativeCursor, getHoveredArc } from '@nivo/core';\nimport { useOrdinalColorScale, useInheritedColor } from '@nivo/colors';\nimport { useTooltip, BasicTooltip } from '@nivo/tooltip';\nimport _get from 'lodash/get';\nimport { pie, arc, line } from 'd3-shape';\nimport { BoxLegendSvg, renderLegendToCanvas } from '@nivo/legends';\n\nvar PieSlice = function PieSlice(_ref) {\n  var datum = _ref.datum,\n      path = _ref.path,\n      borderWidth = _ref.borderWidth,\n      borderColor = _ref.borderColor,\n      isInteractive = _ref.isInteractive,\n      onClick = _ref.onClick,\n      onMouseEnter = _ref.onMouseEnter,\n      onMouseMove = _ref.onMouseMove,\n      onMouseLeave = _ref.onMouseLeave,\n      tooltip = _ref.tooltip;\n\n  var _useTooltip = useTooltip(),\n      showTooltipFromEvent = _useTooltip.showTooltipFromEvent,\n      hideTooltip = _useTooltip.hideTooltip;\n\n  var handleTooltip = useCallback(function (event) {\n    return showTooltipFromEvent(createElement(tooltip, {\n      datum: datum\n    }), event);\n  }, [showTooltipFromEvent, datum, tooltip]);\n  var handleMouseEnter = useCallback(function (event) {\n    onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter(datum, event);\n    handleTooltip(event);\n  }, [onMouseEnter, handleTooltip, datum]);\n  var handleMouseMove = useCallback(function (event) {\n    onMouseMove === null || onMouseMove === void 0 ? void 0 : onMouseMove(datum, event);\n    handleTooltip(event);\n  }, [onMouseMove, handleTooltip, datum]);\n  var handleMouseLeave = useCallback(function (event) {\n    onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave(datum, event);\n    hideTooltip();\n  }, [onMouseLeave, hideTooltip, datum]);\n  var handleClick = useCallback(function (event) {\n    onClick === null || onClick === void 0 ? void 0 : onClick(datum, event);\n  }, [onClick, datum]);\n  return React.createElement(\"path\", {\n    d: path !== null && path !== void 0 ? path : undefined,\n    fill: datum.fill || datum.color,\n    strokeWidth: borderWidth,\n    stroke: borderColor,\n    onMouseEnter: isInteractive ? handleMouseEnter : undefined,\n    onMouseMove: isInteractive ? handleMouseMove : undefined,\n    onMouseLeave: isInteractive ? handleMouseLeave : undefined,\n    onClick: isInteractive ? handleClick : undefined\n  });\n};\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar PieTooltip = function PieTooltip(_ref) {\n  var datum = _ref.datum;\n  return React.createElement(BasicTooltip, {\n    id: datum.id,\n    value: datum.formattedValue,\n    enableChip: true,\n    color: datum.color\n  });\n};\n\nvar _window$devicePixelRa;\n\nvar defaultProps = {\n  id: 'id',\n  value: 'value',\n  sortByValue: false,\n  innerRadius: 0,\n  padAngle: 0,\n  cornerRadius: 0,\n  layers: ['slices', 'radialLabels', 'sliceLabels', 'legends'],\n  startAngle: 0,\n  endAngle: 360,\n  fit: true,\n  borderWidth: 0,\n  borderColor: {\n    from: 'color',\n    modifiers: [['darker', 1]]\n  },\n  radialLabel: 'id',\n  enableRadialLabels: true,\n  radialLabelsSkipAngle: 0,\n  radialLabelsLinkOffset: 0,\n  radialLabelsLinkDiagonalLength: 16,\n  radialLabelsLinkHorizontalLength: 24,\n  radialLabelsLinkStrokeWidth: 1,\n  radialLabelsTextXOffset: 6,\n  radialLabelsTextColor: {\n    theme: 'labels.text.fill'\n  },\n  radialLabelsLinkColor: {\n    theme: 'axis.ticks.line.stroke'\n  },\n  enableSliceLabels: true,\n  sliceLabel: 'formattedValue',\n  sliceLabelsSkipAngle: 0,\n  sliceLabelsRadiusOffset: 0.5,\n  sliceLabelsTextColor: {\n    theme: 'labels.text.fill'\n  },\n  colors: {\n    scheme: 'nivo'\n  },\n  defs: [],\n  fill: [],\n  isInteractive: true,\n  tooltip: PieTooltip,\n  legends: [],\n  role: 'img',\n  pixelRatio: typeof window !== 'undefined' ? (_window$devicePixelRa = window.devicePixelRatio) !== null && _window$devicePixelRa !== void 0 ? _window$devicePixelRa : 1 : 1\n};\n\nvar useNormalizedData = function useNormalizedData(_ref) {\n  var data = _ref.data,\n      _ref$id = _ref.id,\n      id = _ref$id === void 0 ? defaultProps.id : _ref$id,\n      _ref$value = _ref.value,\n      value = _ref$value === void 0 ? defaultProps.value : _ref$value,\n      valueFormat = _ref.valueFormat,\n      _ref$colors = _ref.colors,\n      colors = _ref$colors === void 0 ? defaultProps.colors : _ref$colors;\n  var getId = useMemo(function () {\n    return typeof id === 'function' ? id : function (d) {\n      return _get(d, id);\n    };\n  }, [id]);\n  var getValue = useMemo(function () {\n    return typeof value === 'function' ? value : function (d) {\n      return _get(d, value);\n    };\n  }, [value]);\n  var formatValue = useValueFormatter(valueFormat);\n  var getColor = useOrdinalColorScale(colors, 'id');\n  return useMemo(function () {\n    return data.map(function (datum) {\n      var _datum$label;\n\n      var datumId = getId(datum);\n      var datumValue = getValue(datum);\n      var normalizedDatum = {\n        id: datumId,\n        label: (_datum$label = datum.label) !== null && _datum$label !== void 0 ? _datum$label : datumId,\n        value: datumValue,\n        formattedValue: formatValue(datumValue),\n        data: datum\n      };\n      return _objectSpread2(_objectSpread2({}, normalizedDatum), {}, {\n        color: getColor(normalizedDatum)\n      });\n    });\n  }, [data, getId, getValue, formatValue, getColor]);\n};\n\nvar usePieArcs = function usePieArcs(_ref2) {\n  var data = _ref2.data,\n      _ref2$startAngle = _ref2.startAngle,\n      startAngle = _ref2$startAngle === void 0 ? defaultProps.startAngle : _ref2$startAngle,\n      _ref2$endAngle = _ref2.endAngle,\n      endAngle = _ref2$endAngle === void 0 ? defaultProps.endAngle : _ref2$endAngle,\n      _ref2$padAngle = _ref2.padAngle,\n      padAngle = _ref2$padAngle === void 0 ? defaultProps.padAngle : _ref2$padAngle,\n      _ref2$sortByValue = _ref2.sortByValue,\n      sortByValue = _ref2$sortByValue === void 0 ? defaultProps.sortByValue : _ref2$sortByValue;\n  var pie$1 = useMemo(function () {\n    var innerPie = pie().value(function (d) {\n      return d.value;\n    }).padAngle(degreesToRadians(padAngle)).startAngle(degreesToRadians(startAngle)).endAngle(degreesToRadians(endAngle));\n    if (sortByValue !== true) innerPie.sortValues(null);\n    return innerPie;\n  }, [startAngle, endAngle, padAngle, sortByValue]);\n  return useMemo(function () {\n    return pie$1(data).map(function (arc) {\n      var angle = Math.abs(arc.endAngle - arc.startAngle);\n      return _objectSpread2(_objectSpread2({}, arc.data), {}, {\n        arc: {\n          index: arc.index,\n          startAngle: arc.startAngle,\n          endAngle: arc.endAngle,\n          padAngle: arc.padAngle,\n          angle: angle,\n          angleDeg: radiansToDegrees(angle)\n        }\n      });\n    });\n  }, [pie$1, data]);\n};\n\nvar usePieArcGenerator = function usePieArcGenerator(_ref3) {\n  var radius = _ref3.radius,\n      innerRadius = _ref3.innerRadius,\n      _ref3$cornerRadius = _ref3.cornerRadius,\n      cornerRadius = _ref3$cornerRadius === void 0 ? defaultProps.cornerRadius : _ref3$cornerRadius;\n  return useMemo(function () {\n    return arc().outerRadius(radius).innerRadius(innerRadius).cornerRadius(cornerRadius);\n  }, [radius, innerRadius, cornerRadius]);\n};\n\nvar usePie = function usePie(_ref4) {\n  var data = _ref4.data,\n      radius = _ref4.radius,\n      innerRadius = _ref4.innerRadius,\n      _ref4$startAngle = _ref4.startAngle,\n      startAngle = _ref4$startAngle === void 0 ? defaultProps.startAngle : _ref4$startAngle,\n      _ref4$endAngle = _ref4.endAngle,\n      endAngle = _ref4$endAngle === void 0 ? defaultProps.endAngle : _ref4$endAngle,\n      _ref4$padAngle = _ref4.padAngle,\n      padAngle = _ref4$padAngle === void 0 ? defaultProps.padAngle : _ref4$padAngle,\n      _ref4$sortByValue = _ref4.sortByValue,\n      sortByValue = _ref4$sortByValue === void 0 ? defaultProps.sortByValue : _ref4$sortByValue,\n      _ref4$cornerRadius = _ref4.cornerRadius,\n      cornerRadius = _ref4$cornerRadius === void 0 ? defaultProps.cornerRadius : _ref4$cornerRadius;\n  var dataWithArc = usePieArcs({\n    data: data,\n    startAngle: startAngle,\n    endAngle: endAngle,\n    padAngle: padAngle,\n    sortByValue: sortByValue\n  });\n  var arcGenerator = usePieArcGenerator({\n    radius: radius,\n    innerRadius: innerRadius,\n    cornerRadius: cornerRadius\n  });\n  return {\n    dataWithArc: dataWithArc,\n    arcGenerator: arcGenerator\n  };\n};\n\nvar usePieFromBox = function usePieFromBox(_ref5) {\n  var data = _ref5.data,\n      width = _ref5.width,\n      height = _ref5.height,\n      _ref5$innerRadius = _ref5.innerRadius,\n      innerRadiusRatio = _ref5$innerRadius === void 0 ? defaultProps.innerRadius : _ref5$innerRadius,\n      _ref5$startAngle = _ref5.startAngle,\n      startAngle = _ref5$startAngle === void 0 ? defaultProps.startAngle : _ref5$startAngle,\n      _ref5$endAngle = _ref5.endAngle,\n      endAngle = _ref5$endAngle === void 0 ? defaultProps.endAngle : _ref5$endAngle,\n      _ref5$padAngle = _ref5.padAngle,\n      padAngle = _ref5$padAngle === void 0 ? defaultProps.padAngle : _ref5$padAngle,\n      _ref5$sortByValue = _ref5.sortByValue,\n      sortByValue = _ref5$sortByValue === void 0 ? defaultProps.sortByValue : _ref5$sortByValue,\n      _ref5$cornerRadius = _ref5.cornerRadius,\n      cornerRadius = _ref5$cornerRadius === void 0 ? defaultProps.cornerRadius : _ref5$cornerRadius,\n      _ref5$fit = _ref5.fit,\n      fit = _ref5$fit === void 0 ? defaultProps.fit : _ref5$fit;\n  var dataWithArc = usePieArcs({\n    data: data,\n    startAngle: startAngle,\n    endAngle: endAngle,\n    padAngle: padAngle,\n    sortByValue: sortByValue\n  });\n  var computedProps = useMemo(function () {\n    var radius = Math.min(width, height) / 2;\n    var innerRadius = radius * Math.min(innerRadiusRatio, 1);\n    var centerX = width / 2;\n    var centerY = height / 2;\n    var boundingBox;\n\n    if (fit) {\n      var _computeArcBoundingBo = computeArcBoundingBox(centerX, centerY, radius, startAngle - 90, endAngle - 90),\n          points = _computeArcBoundingBo.points,\n          box = _objectWithoutProperties(_computeArcBoundingBo, [\"points\"]);\n\n      var ratio = Math.min(width / box.width, height / box.height);\n      var adjustedBox = {\n        width: box.width * ratio,\n        height: box.height * ratio\n      };\n      adjustedBox.x = (width - adjustedBox.width) / 2;\n      adjustedBox.y = (height - adjustedBox.height) / 2;\n      centerX = (centerX - box.x) / box.width * box.width * ratio + adjustedBox.x;\n      centerY = (centerY - box.y) / box.height * box.height * ratio + adjustedBox.y;\n      boundingBox = {\n        box: box,\n        ratio: ratio,\n        points: points\n      };\n      radius = radius * ratio;\n      innerRadius = innerRadius * ratio;\n    }\n\n    return {\n      centerX: centerX,\n      centerY: centerY,\n      radius: radius,\n      innerRadius: innerRadius,\n      debug: boundingBox\n    };\n  }, [width, height, innerRadiusRatio, startAngle, endAngle, fit, cornerRadius]);\n  var arcGenerator = usePieArcGenerator({\n    radius: computedProps.radius,\n    innerRadius: computedProps.innerRadius,\n    cornerRadius: cornerRadius\n  });\n  return _objectSpread2({\n    dataWithArc: dataWithArc,\n    arcGenerator: arcGenerator\n  }, computedProps);\n};\n\nvar usePieSliceLabels = function usePieSliceLabels(_ref6) {\n  var enable = _ref6.enable,\n      dataWithArc = _ref6.dataWithArc,\n      skipAngle = _ref6.skipAngle,\n      radius = _ref6.radius,\n      innerRadius = _ref6.innerRadius,\n      radiusOffset = _ref6.radiusOffset,\n      label = _ref6.label,\n      textColor = _ref6.textColor;\n  var theme = useTheme();\n  var getTextColor = useInheritedColor(textColor, theme);\n  var getLabel = useMemo(function () {\n    return getLabelGenerator(label);\n  }, [label]);\n  return useMemo(function () {\n    if (!enable) return [];\n    return dataWithArc.filter(function (datumWithArc) {\n      return skipAngle === 0 || datumWithArc.arc.angleDeg > skipAngle;\n    }).map(function (datumWithArc) {\n      var angle = midAngle(datumWithArc.arc) - Math.PI / 2;\n      var labelRadius = innerRadius + (radius - innerRadius) * radiusOffset;\n      var position = positionFromAngle(angle, labelRadius);\n      var datumTextColor = getTextColor(datumWithArc);\n      return _objectSpread2(_objectSpread2({}, position), {}, {\n        label: getLabel(datumWithArc),\n        textColor: datumTextColor,\n        datum: datumWithArc\n      });\n    });\n  }, [enable, dataWithArc, skipAngle, radius, innerRadius, radiusOffset, getLabel, getTextColor]);\n};\n\nvar usePieRadialLabels = function usePieRadialLabels(_ref7) {\n  var enable = _ref7.enable,\n      dataWithArc = _ref7.dataWithArc,\n      label = _ref7.label,\n      textXOffset = _ref7.textXOffset,\n      textColor = _ref7.textColor,\n      radius = _ref7.radius,\n      skipAngle = _ref7.skipAngle,\n      linkOffset = _ref7.linkOffset,\n      linkDiagonalLength = _ref7.linkDiagonalLength,\n      linkHorizontalLength = _ref7.linkHorizontalLength,\n      linkColor = _ref7.linkColor;\n  var getLabel = useMemo(function () {\n    return getLabelGenerator(label);\n  }, [label]);\n  var theme = useTheme();\n  var getTextColor = useInheritedColor(textColor, theme);\n  var getLinkColor = useInheritedColor(linkColor, theme);\n  return useMemo(function () {\n    if (!enable) return [];\n    return dataWithArc.filter(function (datum) {\n      return skipAngle === 0 || datum.arc.angleDeg > skipAngle;\n    }).map(function (datum) {\n      var angle = absoluteAngleRadians(midAngle(datum.arc) - Math.PI / 2);\n      var positionA = positionFromAngle(angle, radius + linkOffset);\n      var positionB = positionFromAngle(angle, radius + linkOffset + linkDiagonalLength);\n      var positionC;\n      var labelPosition;\n      var textAlign;\n\n      if (absoluteAngleDegrees(radiansToDegrees(angle)) < 90 || absoluteAngleDegrees(radiansToDegrees(angle)) >= 270) {\n        positionC = {\n          x: positionB.x + linkHorizontalLength,\n          y: positionB.y\n        };\n        labelPosition = {\n          x: positionB.x + linkHorizontalLength + textXOffset,\n          y: positionB.y\n        };\n        textAlign = 'left';\n      } else {\n        positionC = {\n          x: positionB.x - linkHorizontalLength,\n          y: positionB.y\n        };\n        labelPosition = {\n          x: positionB.x - linkHorizontalLength - textXOffset,\n          y: positionB.y\n        };\n        textAlign = 'right';\n      }\n\n      return {\n        text: getLabel(datum),\n        textColor: getTextColor(datum),\n        position: labelPosition,\n        align: textAlign,\n        line: [positionA, positionB, positionC],\n        linkColor: getLinkColor(datum),\n        datum: datum\n      };\n    });\n  }, [dataWithArc, skipAngle, radius, linkOffset, linkDiagonalLength, linkHorizontalLength, textXOffset, getLabel, getTextColor, getLinkColor]);\n};\n\nvar usePieLayerContext = function usePieLayerContext(_ref8) {\n  var dataWithArc = _ref8.dataWithArc,\n      arcGenerator = _ref8.arcGenerator,\n      centerX = _ref8.centerX,\n      centerY = _ref8.centerY,\n      radius = _ref8.radius,\n      innerRadius = _ref8.innerRadius;\n  return useMemo(function () {\n    return {\n      dataWithArc: dataWithArc,\n      arcGenerator: arcGenerator,\n      centerX: centerX,\n      centerY: centerY,\n      radius: radius,\n      innerRadius: innerRadius\n    };\n  }, [dataWithArc, arcGenerator, centerX, centerY, radius, innerRadius]);\n};\n\nvar lineGenerator = line().x(function (d) {\n  return d.x;\n}).y(function (d) {\n  return d.y;\n});\n\nvar RadialLabel = function RadialLabel(_ref) {\n  var _lineGenerator;\n\n  var label = _ref.label,\n      linkStrokeWidth = _ref.linkStrokeWidth;\n  var theme = useTheme();\n  return React.createElement(React.Fragment, null, React.createElement(\"path\", {\n    d: (_lineGenerator = lineGenerator(label.line)) !== null && _lineGenerator !== void 0 ? _lineGenerator : undefined,\n    fill: \"none\",\n    style: {\n      fill: 'none',\n      stroke: label.linkColor\n    },\n    strokeWidth: linkStrokeWidth\n  }), React.createElement(\"g\", {\n    transform: \"translate(\".concat(label.position.x, \", \").concat(label.position.y, \")\")\n  }, React.createElement(\"text\", {\n    textAnchor: textPropsByEngine.svg.align[label.align],\n    dominantBaseline: \"central\",\n    style: _objectSpread2(_objectSpread2({}, theme.labels.text), {}, {\n      fill: label.textColor\n    })\n  }, label.text)));\n};\n\nvar RadialLabels = function RadialLabels(_ref) {\n  var dataWithArc = _ref.dataWithArc,\n      label = _ref.label,\n      radius = _ref.radius,\n      skipAngle = _ref.skipAngle,\n      linkOffset = _ref.linkOffset,\n      linkDiagonalLength = _ref.linkDiagonalLength,\n      linkHorizontalLength = _ref.linkHorizontalLength,\n      linkStrokeWidth = _ref.linkStrokeWidth,\n      textXOffset = _ref.textXOffset,\n      textColor = _ref.textColor,\n      linkColor = _ref.linkColor;\n  var radialLabels = usePieRadialLabels({\n    enable: true,\n    dataWithArc: dataWithArc,\n    label: label,\n    textXOffset: textXOffset,\n    textColor: textColor,\n    radius: radius,\n    skipAngle: skipAngle,\n    linkOffset: linkOffset,\n    linkDiagonalLength: linkDiagonalLength,\n    linkHorizontalLength: linkHorizontalLength,\n    linkColor: linkColor\n  });\n  return React.createElement(React.Fragment, null, radialLabels.map(function (labelData) {\n    return React.createElement(RadialLabel, {\n      key: labelData.datum.id,\n      label: labelData,\n      linkStrokeWidth: linkStrokeWidth\n    });\n  }));\n};\n\nvar sliceStyle = {\n  pointerEvents: 'none'\n};\n\nvar SliceLabels = function SliceLabels(_ref) {\n  var dataWithArc = _ref.dataWithArc,\n      labelAccessor = _ref.label,\n      radius = _ref.radius,\n      innerRadius = _ref.innerRadius,\n      radiusOffset = _ref.radiusOffset,\n      skipAngle = _ref.skipAngle,\n      textColor = _ref.textColor;\n  var theme = useTheme();\n  var labels = usePieSliceLabels({\n    enable: true,\n    dataWithArc: dataWithArc,\n    skipAngle: skipAngle,\n    radius: radius,\n    innerRadius: innerRadius,\n    radiusOffset: radiusOffset,\n    label: labelAccessor,\n    textColor: textColor\n  });\n  return React.createElement(React.Fragment, null, labels.map(function (label) {\n    return React.createElement(\"g\", {\n      key: label.datum.id,\n      transform: \"translate(\".concat(label.x, \", \").concat(label.y, \")\"),\n      style: sliceStyle\n    }, React.createElement(\"text\", {\n      textAnchor: \"middle\",\n      dominantBaseline: \"central\",\n      style: _objectSpread2(_objectSpread2({}, theme.labels.text), {}, {\n        fill: label.textColor\n      })\n    }, label.label));\n  }));\n};\n\nvar PieLegends = function PieLegends(_ref) {\n  var width = _ref.width,\n      height = _ref.height,\n      legends = _ref.legends,\n      dataWithArc = _ref.dataWithArc;\n  return React.createElement(React.Fragment, null, legends.map(function (legend, i) {\n    return React.createElement(BoxLegendSvg, Object.assign({\n      key: i\n    }, legend, {\n      containerWidth: width,\n      containerHeight: height,\n      data: dataWithArc\n    }));\n  }));\n};\n\nvar Pie = function Pie(_ref) {\n  var data = _ref.data,\n      _ref$id = _ref.id,\n      id = _ref$id === void 0 ? defaultProps.id : _ref$id,\n      _ref$value = _ref.value,\n      value = _ref$value === void 0 ? defaultProps.value : _ref$value,\n      valueFormat = _ref.valueFormat,\n      _ref$sortByValue = _ref.sortByValue,\n      sortByValue = _ref$sortByValue === void 0 ? defaultProps.sortByValue : _ref$sortByValue,\n      _ref$layers = _ref.layers,\n      layers = _ref$layers === void 0 ? defaultProps.layers : _ref$layers,\n      _ref$startAngle = _ref.startAngle,\n      startAngle = _ref$startAngle === void 0 ? defaultProps.startAngle : _ref$startAngle,\n      _ref$endAngle = _ref.endAngle,\n      endAngle = _ref$endAngle === void 0 ? defaultProps.endAngle : _ref$endAngle,\n      _ref$padAngle = _ref.padAngle,\n      padAngle = _ref$padAngle === void 0 ? defaultProps.padAngle : _ref$padAngle,\n      _ref$fit = _ref.fit,\n      fit = _ref$fit === void 0 ? defaultProps.fit : _ref$fit,\n      _ref$innerRadius = _ref.innerRadius,\n      innerRadiusRatio = _ref$innerRadius === void 0 ? defaultProps.innerRadius : _ref$innerRadius,\n      _ref$cornerRadius = _ref.cornerRadius,\n      cornerRadius = _ref$cornerRadius === void 0 ? defaultProps.cornerRadius : _ref$cornerRadius,\n      width = _ref.width,\n      height = _ref.height,\n      partialMargin = _ref.margin,\n      _ref$colors = _ref.colors,\n      colors = _ref$colors === void 0 ? defaultProps.colors : _ref$colors,\n      _ref$borderWidth = _ref.borderWidth,\n      borderWidth = _ref$borderWidth === void 0 ? defaultProps.borderWidth : _ref$borderWidth,\n      _ref$borderColor = _ref.borderColor,\n      _borderColor = _ref$borderColor === void 0 ? defaultProps.borderColor : _ref$borderColor,\n      _ref$radialLabel = _ref.radialLabel,\n      radialLabel = _ref$radialLabel === void 0 ? defaultProps.radialLabel : _ref$radialLabel,\n      _ref$enableRadialLabe = _ref.enableRadialLabels,\n      enableRadialLabels = _ref$enableRadialLabe === void 0 ? defaultProps.enableRadialLabels : _ref$enableRadialLabe,\n      _ref$radialLabelsSkip = _ref.radialLabelsSkipAngle,\n      radialLabelsSkipAngle = _ref$radialLabelsSkip === void 0 ? defaultProps.radialLabelsSkipAngle : _ref$radialLabelsSkip,\n      _ref$radialLabelsLink = _ref.radialLabelsLinkOffset,\n      radialLabelsLinkOffset = _ref$radialLabelsLink === void 0 ? defaultProps.radialLabelsLinkOffset : _ref$radialLabelsLink,\n      _ref$radialLabelsLink2 = _ref.radialLabelsLinkDiagonalLength,\n      radialLabelsLinkDiagonalLength = _ref$radialLabelsLink2 === void 0 ? defaultProps.radialLabelsLinkDiagonalLength : _ref$radialLabelsLink2,\n      _ref$radialLabelsLink3 = _ref.radialLabelsLinkHorizontalLength,\n      radialLabelsLinkHorizontalLength = _ref$radialLabelsLink3 === void 0 ? defaultProps.radialLabelsLinkHorizontalLength : _ref$radialLabelsLink3,\n      _ref$radialLabelsLink4 = _ref.radialLabelsLinkStrokeWidth,\n      radialLabelsLinkStrokeWidth = _ref$radialLabelsLink4 === void 0 ? defaultProps.radialLabelsLinkStrokeWidth : _ref$radialLabelsLink4,\n      _ref$radialLabelsText = _ref.radialLabelsTextXOffset,\n      radialLabelsTextXOffset = _ref$radialLabelsText === void 0 ? defaultProps.radialLabelsTextXOffset : _ref$radialLabelsText,\n      _ref$radialLabelsText2 = _ref.radialLabelsTextColor,\n      radialLabelsTextColor = _ref$radialLabelsText2 === void 0 ? defaultProps.radialLabelsTextColor : _ref$radialLabelsText2,\n      _ref$radialLabelsLink5 = _ref.radialLabelsLinkColor,\n      radialLabelsLinkColor = _ref$radialLabelsLink5 === void 0 ? defaultProps.radialLabelsLinkColor : _ref$radialLabelsLink5,\n      _ref$sliceLabel = _ref.sliceLabel,\n      sliceLabel = _ref$sliceLabel === void 0 ? defaultProps.sliceLabel : _ref$sliceLabel,\n      _ref$enableSliceLabel = _ref.enableSliceLabels,\n      enableSliceLabels = _ref$enableSliceLabel === void 0 ? defaultProps.enableSliceLabels : _ref$enableSliceLabel,\n      _ref$sliceLabelsSkipA = _ref.sliceLabelsSkipAngle,\n      sliceLabelsSkipAngle = _ref$sliceLabelsSkipA === void 0 ? defaultProps.sliceLabelsSkipAngle : _ref$sliceLabelsSkipA,\n      _ref$sliceLabelsTextC = _ref.sliceLabelsTextColor,\n      sliceLabelsTextColor = _ref$sliceLabelsTextC === void 0 ? defaultProps.sliceLabelsTextColor : _ref$sliceLabelsTextC,\n      _ref$sliceLabelsRadiu = _ref.sliceLabelsRadiusOffset,\n      sliceLabelsRadiusOffset = _ref$sliceLabelsRadiu === void 0 ? defaultProps.sliceLabelsRadiusOffset : _ref$sliceLabelsRadiu,\n      _ref$defs = _ref.defs,\n      defs = _ref$defs === void 0 ? defaultProps.defs : _ref$defs,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === void 0 ? defaultProps.fill : _ref$fill,\n      _ref$isInteractive = _ref.isInteractive,\n      isInteractive = _ref$isInteractive === void 0 ? defaultProps.isInteractive : _ref$isInteractive,\n      onClick = _ref.onClick,\n      onMouseEnter = _ref.onMouseEnter,\n      onMouseMove = _ref.onMouseMove,\n      onMouseLeave = _ref.onMouseLeave,\n      _ref$tooltip = _ref.tooltip,\n      tooltip = _ref$tooltip === void 0 ? defaultProps.tooltip : _ref$tooltip,\n      _ref$legends = _ref.legends,\n      legends = _ref$legends === void 0 ? defaultProps.legends : _ref$legends,\n      _ref$role = _ref.role,\n      role = _ref$role === void 0 ? defaultProps.role : _ref$role;\n\n  var theme = useTheme();\n\n  var _useDimensions = useDimensions(width, height, partialMargin),\n      outerWidth = _useDimensions.outerWidth,\n      outerHeight = _useDimensions.outerHeight,\n      margin = _useDimensions.margin,\n      innerWidth = _useDimensions.innerWidth,\n      innerHeight = _useDimensions.innerHeight;\n\n  var normalizedData = useNormalizedData({\n    data: data,\n    id: id,\n    value: value,\n    valueFormat: valueFormat,\n    colors: colors\n  });\n\n  var _usePieFromBox = usePieFromBox({\n    data: normalizedData,\n    width: innerWidth,\n    height: innerHeight,\n    fit: fit,\n    innerRadius: innerRadiusRatio,\n    startAngle: startAngle,\n    endAngle: endAngle,\n    padAngle: padAngle,\n    sortByValue: sortByValue,\n    cornerRadius: cornerRadius\n  }),\n      dataWithArc = _usePieFromBox.dataWithArc,\n      arcGenerator = _usePieFromBox.arcGenerator,\n      centerX = _usePieFromBox.centerX,\n      centerY = _usePieFromBox.centerY,\n      radius = _usePieFromBox.radius,\n      innerRadius = _usePieFromBox.innerRadius;\n\n  var borderColor = useInheritedColor(_borderColor, theme);\n  var boundDefs = bindDefs(defs, dataWithArc, fill);\n  var layerById = {\n    slices: null,\n    radialLabels: null,\n    sliceLabels: null,\n    legends: null\n  };\n\n  if (layers.includes('slices')) {\n    layerById.slices = React.createElement(\"g\", {\n      key: \"slices\",\n      transform: \"translate(\".concat(centerX, \",\").concat(centerY, \")\")\n    }, dataWithArc.map(function (datumWithArc) {\n      var _arcGenerator;\n\n      return React.createElement(PieSlice, {\n        key: datumWithArc.id,\n        datum: datumWithArc,\n        path: (_arcGenerator = arcGenerator(datumWithArc.arc)) !== null && _arcGenerator !== void 0 ? _arcGenerator : undefined,\n        borderWidth: borderWidth,\n        borderColor: borderColor(datumWithArc),\n        tooltip: tooltip,\n        isInteractive: isInteractive,\n        onClick: onClick,\n        onMouseEnter: onMouseEnter,\n        onMouseMove: onMouseMove,\n        onMouseLeave: onMouseLeave\n      });\n    }));\n  }\n\n  if (enableRadialLabels && layers.includes('radialLabels')) {\n    layerById.radialLabels = React.createElement(\"g\", {\n      key: \"radialLabels\",\n      transform: \"translate(\".concat(centerX, \",\").concat(centerY, \")\")\n    }, React.createElement(RadialLabels, {\n      dataWithArc: dataWithArc,\n      radius: radius,\n      label: radialLabel,\n      skipAngle: radialLabelsSkipAngle,\n      linkOffset: radialLabelsLinkOffset,\n      linkDiagonalLength: radialLabelsLinkDiagonalLength,\n      linkHorizontalLength: radialLabelsLinkHorizontalLength,\n      linkStrokeWidth: radialLabelsLinkStrokeWidth,\n      textXOffset: radialLabelsTextXOffset,\n      textColor: radialLabelsTextColor,\n      linkColor: radialLabelsLinkColor\n    }));\n  }\n\n  if (enableSliceLabels && layers.includes('sliceLabels')) {\n    layerById.sliceLabels = React.createElement(\"g\", {\n      key: \"sliceLabels\",\n      transform: \"translate(\".concat(centerX, \",\").concat(centerY, \")\")\n    }, React.createElement(SliceLabels, {\n      dataWithArc: dataWithArc,\n      label: sliceLabel,\n      radius: radius,\n      innerRadius: innerRadius,\n      radiusOffset: sliceLabelsRadiusOffset,\n      skipAngle: sliceLabelsSkipAngle,\n      textColor: sliceLabelsTextColor\n    }));\n  }\n\n  if (legends.length > 0 && layers.includes('legends')) {\n    layerById.legends = React.createElement(PieLegends, {\n      key: \"legends\",\n      width: innerWidth,\n      height: innerHeight,\n      dataWithArc: dataWithArc,\n      legends: legends\n    });\n  }\n\n  var layerContext = usePieLayerContext({\n    dataWithArc: dataWithArc,\n    arcGenerator: arcGenerator,\n    centerX: centerX,\n    centerY: centerY,\n    radius: radius,\n    innerRadius: innerRadius\n  });\n  return React.createElement(SvgWrapper, {\n    width: outerWidth,\n    height: outerHeight,\n    margin: margin,\n    defs: boundDefs,\n    role: role\n  }, layers.map(function (layer, i) {\n    if (layerById[layer] !== undefined) {\n      return layerById[layer];\n    }\n\n    if (typeof layer === 'function') {\n      return React.createElement(Fragment, {\n        key: i\n      }, createElement(layer, layerContext));\n    }\n\n    return null;\n  }));\n};\n\nvar Pie$1 = withContainer(Pie);\n\nvar ResponsivePie = function ResponsivePie(props) {\n  return React.createElement(ResponsiveWrapper, null, function (_ref) {\n    var width = _ref.width,\n        height = _ref.height;\n    return React.createElement(Pie$1, Object.assign({\n      width: width,\n      height: height\n    }, props));\n  });\n};\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nvar drawSliceLabels = function drawSliceLabels(ctx, labels, theme) {\n  ctx.textAlign = 'center';\n  ctx.textBaseline = 'middle';\n  ctx.font = \"\".concat(theme.labels.text.fontSize, \"px \").concat(theme.labels.text.fontFamily);\n  labels.forEach(function (label) {\n    ctx.save();\n    ctx.translate(label.x, label.y);\n    ctx.fillStyle = label.textColor;\n    ctx.fillText(\"\".concat(label.label), 0, 0);\n    ctx.restore();\n  });\n};\n\nvar drawRadialLabels = function drawRadialLabels(ctx, labels, theme, linkStrokeWidth) {\n  ctx.textBaseline = 'middle';\n  ctx.font = \"\".concat(theme.labels.text.fontSize, \"px \").concat(theme.labels.text.fontFamily);\n  labels.forEach(function (label) {\n    ctx.save();\n    ctx.translate(label.position.x, label.position.y);\n    ctx.fillStyle = label.textColor;\n    ctx.textAlign = textPropsByEngine.canvas.align[label.align];\n    ctx.fillText(\"\".concat(label.text), 0, 0);\n    ctx.restore();\n    ctx.beginPath();\n    ctx.strokeStyle = label.linkColor;\n    ctx.lineWidth = linkStrokeWidth;\n    label.line.forEach(function (point, index) {\n      if (index === 0) ctx.moveTo(point.x, point.y);else ctx.lineTo(point.x, point.y);\n    });\n    if (linkStrokeWidth > 0) ctx.stroke();\n  });\n};\n\nvar PieCanvas = function PieCanvas(_ref) {\n  var data = _ref.data,\n      _ref$id = _ref.id,\n      id = _ref$id === void 0 ? defaultProps.id : _ref$id,\n      _ref$value = _ref.value,\n      value = _ref$value === void 0 ? defaultProps.value : _ref$value,\n      valueFormat = _ref.valueFormat,\n      _ref$sortByValue = _ref.sortByValue,\n      sortByValue = _ref$sortByValue === void 0 ? defaultProps.sortByValue : _ref$sortByValue,\n      _ref$startAngle = _ref.startAngle,\n      startAngle = _ref$startAngle === void 0 ? defaultProps.startAngle : _ref$startAngle,\n      _ref$endAngle = _ref.endAngle,\n      endAngle = _ref$endAngle === void 0 ? defaultProps.endAngle : _ref$endAngle,\n      _ref$padAngle = _ref.padAngle,\n      padAngle = _ref$padAngle === void 0 ? defaultProps.padAngle : _ref$padAngle,\n      _ref$fit = _ref.fit,\n      fit = _ref$fit === void 0 ? defaultProps.fit : _ref$fit,\n      _ref$innerRadius = _ref.innerRadius,\n      innerRadiusRatio = _ref$innerRadius === void 0 ? defaultProps.innerRadius : _ref$innerRadius,\n      _ref$cornerRadius = _ref.cornerRadius,\n      cornerRadius = _ref$cornerRadius === void 0 ? defaultProps.cornerRadius : _ref$cornerRadius,\n      width = _ref.width,\n      height = _ref.height,\n      partialMargin = _ref.margin,\n      _ref$pixelRatio = _ref.pixelRatio,\n      pixelRatio = _ref$pixelRatio === void 0 ? 1 : _ref$pixelRatio,\n      _ref$colors = _ref.colors,\n      colors = _ref$colors === void 0 ? defaultProps.colors : _ref$colors,\n      _ref$borderWidth = _ref.borderWidth,\n      borderWidth = _ref$borderWidth === void 0 ? defaultProps.borderWidth : _ref$borderWidth,\n      _ref$borderColor = _ref.borderColor,\n      borderColor = _ref$borderColor === void 0 ? defaultProps.borderColor : _ref$borderColor,\n      _ref$radialLabel = _ref.radialLabel,\n      radialLabel = _ref$radialLabel === void 0 ? defaultProps.radialLabel : _ref$radialLabel,\n      _ref$enableRadialLabe = _ref.enableRadialLabels,\n      enableRadialLabels = _ref$enableRadialLabe === void 0 ? defaultProps.enableRadialLabels : _ref$enableRadialLabe,\n      _ref$radialLabelsSkip = _ref.radialLabelsSkipAngle,\n      radialLabelsSkipAngle = _ref$radialLabelsSkip === void 0 ? defaultProps.radialLabelsSkipAngle : _ref$radialLabelsSkip,\n      _ref$radialLabelsLink = _ref.radialLabelsLinkOffset,\n      radialLabelsLinkOffset = _ref$radialLabelsLink === void 0 ? defaultProps.radialLabelsLinkOffset : _ref$radialLabelsLink,\n      _ref$radialLabelsLink2 = _ref.radialLabelsLinkDiagonalLength,\n      radialLabelsLinkDiagonalLength = _ref$radialLabelsLink2 === void 0 ? defaultProps.radialLabelsLinkDiagonalLength : _ref$radialLabelsLink2,\n      _ref$radialLabelsLink3 = _ref.radialLabelsLinkHorizontalLength,\n      radialLabelsLinkHorizontalLength = _ref$radialLabelsLink3 === void 0 ? defaultProps.radialLabelsLinkHorizontalLength : _ref$radialLabelsLink3,\n      _ref$radialLabelsLink4 = _ref.radialLabelsLinkStrokeWidth,\n      radialLabelsLinkStrokeWidth = _ref$radialLabelsLink4 === void 0 ? defaultProps.radialLabelsLinkStrokeWidth : _ref$radialLabelsLink4,\n      _ref$radialLabelsText = _ref.radialLabelsTextXOffset,\n      radialLabelsTextXOffset = _ref$radialLabelsText === void 0 ? defaultProps.radialLabelsTextXOffset : _ref$radialLabelsText,\n      _ref$radialLabelsText2 = _ref.radialLabelsTextColor,\n      radialLabelsTextColor = _ref$radialLabelsText2 === void 0 ? defaultProps.radialLabelsTextColor : _ref$radialLabelsText2,\n      _ref$radialLabelsLink5 = _ref.radialLabelsLinkColor,\n      radialLabelsLinkColor = _ref$radialLabelsLink5 === void 0 ? defaultProps.radialLabelsLinkColor : _ref$radialLabelsLink5,\n      _ref$sliceLabel = _ref.sliceLabel,\n      sliceLabel = _ref$sliceLabel === void 0 ? defaultProps.sliceLabel : _ref$sliceLabel,\n      _ref$enableSliceLabel = _ref.enableSliceLabels,\n      enableSliceLabels = _ref$enableSliceLabel === void 0 ? defaultProps.enableSliceLabels : _ref$enableSliceLabel,\n      _ref$sliceLabelsSkipA = _ref.sliceLabelsSkipAngle,\n      sliceLabelsSkipAngle = _ref$sliceLabelsSkipA === void 0 ? defaultProps.sliceLabelsSkipAngle : _ref$sliceLabelsSkipA,\n      _ref$sliceLabelsTextC = _ref.sliceLabelsTextColor,\n      sliceLabelsTextColor = _ref$sliceLabelsTextC === void 0 ? defaultProps.sliceLabelsTextColor : _ref$sliceLabelsTextC,\n      _ref$sliceLabelsRadiu = _ref.sliceLabelsRadiusOffset,\n      sliceLabelsRadiusOffset = _ref$sliceLabelsRadiu === void 0 ? defaultProps.sliceLabelsRadiusOffset : _ref$sliceLabelsRadiu,\n      _ref$isInteractive = _ref.isInteractive,\n      isInteractive = _ref$isInteractive === void 0 ? defaultProps.isInteractive : _ref$isInteractive,\n      onClick = _ref.onClick,\n      onMouseMove = _ref.onMouseMove,\n      _ref$tooltip = _ref.tooltip,\n      tooltip = _ref$tooltip === void 0 ? defaultProps.tooltip : _ref$tooltip,\n      _ref$legends = _ref.legends,\n      legends = _ref$legends === void 0 ? defaultProps.legends : _ref$legends;\n  var canvasEl = useRef(null);\n  var theme = useTheme();\n\n  var _useDimensions = useDimensions(width, height, partialMargin),\n      margin = _useDimensions.margin,\n      innerWidth = _useDimensions.innerWidth,\n      innerHeight = _useDimensions.innerHeight,\n      outerWidth = _useDimensions.outerWidth,\n      outerHeight = _useDimensions.outerHeight;\n\n  var normalizedData = useNormalizedData({\n    data: data,\n    id: id,\n    value: value,\n    valueFormat: valueFormat,\n    colors: colors\n  });\n\n  var _usePieFromBox = usePieFromBox({\n    data: normalizedData,\n    width: innerWidth,\n    height: innerHeight,\n    fit: fit,\n    innerRadius: innerRadiusRatio,\n    startAngle: startAngle,\n    endAngle: endAngle,\n    padAngle: padAngle,\n    sortByValue: sortByValue,\n    cornerRadius: cornerRadius\n  }),\n      dataWithArc = _usePieFromBox.dataWithArc,\n      arcGenerator = _usePieFromBox.arcGenerator,\n      centerX = _usePieFromBox.centerX,\n      centerY = _usePieFromBox.centerY,\n      radius = _usePieFromBox.radius,\n      innerRadius = _usePieFromBox.innerRadius;\n\n  var getBorderColor = useInheritedColor(borderColor, theme);\n  var radialLabels = usePieRadialLabels({\n    enable: enableRadialLabels,\n    dataWithArc: dataWithArc,\n    label: radialLabel,\n    textXOffset: radialLabelsTextXOffset,\n    textColor: radialLabelsTextColor,\n    radius: radius,\n    skipAngle: radialLabelsSkipAngle,\n    linkOffset: radialLabelsLinkOffset,\n    linkDiagonalLength: radialLabelsLinkDiagonalLength,\n    linkHorizontalLength: radialLabelsLinkHorizontalLength,\n    linkColor: radialLabelsLinkColor\n  });\n  var sliceLabels = usePieSliceLabels({\n    enable: enableSliceLabels,\n    dataWithArc: dataWithArc,\n    label: sliceLabel,\n    radius: radius,\n    innerRadius: innerRadius,\n    radiusOffset: sliceLabelsRadiusOffset,\n    skipAngle: sliceLabelsSkipAngle,\n    textColor: sliceLabelsTextColor\n  });\n  useEffect(function () {\n    if (!canvasEl.current) return;\n    canvasEl.current.width = outerWidth * pixelRatio;\n    canvasEl.current.height = outerHeight * pixelRatio;\n    var ctx = canvasEl.current.getContext('2d');\n    ctx.scale(pixelRatio, pixelRatio);\n    ctx.fillStyle = theme.background;\n    ctx.fillRect(0, 0, outerWidth, outerHeight);\n    ctx.save();\n    ctx.translate(margin.left, margin.top);\n    arcGenerator.context(ctx);\n    ctx.save();\n    ctx.translate(centerX, centerY);\n    dataWithArc.forEach(function (arc) {\n      ctx.beginPath();\n      ctx.fillStyle = arc.color;\n      ctx.strokeStyle = getBorderColor(arc);\n      ctx.lineWidth = borderWidth;\n      arcGenerator(arc.arc);\n      ctx.fill();\n\n      if (borderWidth > 0) {\n        ctx.stroke();\n      }\n    });\n\n    if (enableRadialLabels === true) {\n      drawRadialLabels(ctx, radialLabels, theme, radialLabelsLinkStrokeWidth);\n    }\n\n    if (enableSliceLabels === true) {\n      drawSliceLabels(ctx, sliceLabels, theme);\n    }\n\n    ctx.restore();\n    legends.forEach(function (legend) {\n      renderLegendToCanvas(ctx, _objectSpread2(_objectSpread2({}, legend), {}, {\n        data: dataWithArc,\n        containerWidth: innerWidth,\n        containerHeight: innerHeight,\n        theme: theme\n      }));\n    });\n  }, [canvasEl, innerWidth, innerHeight, outerWidth, outerHeight, margin.top, margin.left, pixelRatio, centerX, centerY, arcGenerator, dataWithArc, getBorderColor, enableRadialLabels, radialLabels, enableSliceLabels, sliceLabels, legends, theme]);\n  var arcs = useMemo(function () {\n    return dataWithArc.map(function (datum) {\n      return _objectSpread2({\n        id: datum.id\n      }, datum.arc);\n    });\n  }, [dataWithArc]);\n\n  var getArcFromMouse = function getArcFromMouse(event) {\n    var _getRelativeCursor = getRelativeCursor(canvasEl.current, event),\n        _getRelativeCursor2 = _slicedToArray(_getRelativeCursor, 2),\n        x = _getRelativeCursor2[0],\n        y = _getRelativeCursor2[1];\n\n    var hoveredArc = getHoveredArc(margin.left + centerX, margin.top + centerY, radius, innerRadius, arcs, x, y);\n    if (!hoveredArc) return null;\n    return dataWithArc.find(function (datum) {\n      return datum.id === hoveredArc.id;\n    });\n  };\n\n  var _useTooltip = useTooltip(),\n      showTooltipFromEvent = _useTooltip.showTooltipFromEvent,\n      hideTooltip = _useTooltip.hideTooltip;\n\n  var handleMouseHover = function handleMouseHover(event) {\n    var datum = getArcFromMouse(event);\n\n    if (datum) {\n      onMouseMove === null || onMouseMove === void 0 ? void 0 : onMouseMove(datum, event);\n      showTooltipFromEvent(createElement(tooltip, {\n        datum: datum\n      }), event);\n    } else {\n      hideTooltip();\n    }\n  };\n\n  var handleMouseLeave = function handleMouseLeave() {\n    hideTooltip();\n  };\n\n  var handleClick = function handleClick(event) {\n    if (!onClick) return;\n    var arc = getArcFromMouse(event);\n\n    if (arc) {\n      onClick(arc, event);\n    }\n  };\n\n  return React.createElement(\"canvas\", {\n    ref: canvasEl,\n    width: outerWidth * pixelRatio,\n    height: outerHeight * pixelRatio,\n    style: {\n      width: outerWidth,\n      height: outerHeight,\n      cursor: isInteractive ? 'auto' : 'normal'\n    },\n    onMouseEnter: isInteractive ? handleMouseHover : undefined,\n    onMouseMove: isInteractive ? handleMouseHover : undefined,\n    onMouseLeave: isInteractive ? handleMouseLeave : undefined,\n    onClick: isInteractive ? handleClick : undefined\n  });\n};\n\nvar PieCanvas$1 = withContainer(PieCanvas);\n\nvar ResponsivePieCanvas = function ResponsivePieCanvas(props) {\n  return React.createElement(ResponsiveWrapper, null, function (_ref) {\n    var width = _ref.width,\n        height = _ref.height;\n    return React.createElement(PieCanvas$1, Object.assign({\n      width: width,\n      height: height\n    }, props));\n  });\n};\n\nexport { Pie$1 as Pie, PieCanvas$1 as PieCanvas, ResponsivePie, ResponsivePieCanvas, defaultProps, useNormalizedData, usePie, usePieArcGenerator, usePieArcs, usePieFromBox, usePieLayerContext, usePieRadialLabels, usePieSliceLabels };","map":null,"metadata":{},"sourceType":"module"}